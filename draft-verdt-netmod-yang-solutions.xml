<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC6020 SYSTEM "reference.RFC.6020.xml">
  <!ENTITY RFC7895 SYSTEM "reference.RFC.7895.xml">
  <!ENTITY RFC7950 SYSTEM "reference.RFC.7950.xml">
  <!ENTITY RFC8199 SYSTEM "reference.RFC.8199.xml">
  <!ENTITY RFC8299 SYSTEM "reference.RFC.8299.xml">
  <!ENTITY RFC8049 SYSTEM "reference.RFC.8049.xml">
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="info" ipr="trust200902" docName="draft-verdt-netmod-yang-solutions-00">
  <front>
    <title abbrev="YANG Versioning Potential Solutions">YANG Versioning Potential Solutions</title>

    <author initials="R." surname="Wilton" fullname="Robert Wilton">
      <organization>Cisco Systems, Inc.</organization>
    </author>
  <!--
    <author initials="J." surname="Clarke" fullname="Joe Clarke">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>7200-12 Kit Creek Rd</street>
          <city>Research Triangle Park</city>
          <region>North Carolina</region>
          <country>United States of America</country>
        </postal>
        <phone>+1-919-392-2867</phone>
        <email>jclarke@cisco.com</email>
      </address>
    </author>
-->
    <date/>
    <abstract>
      <t>
	This document describes and evalutes potential solutions to
	the requirements stated in section 5 of the YANG versioning
	requirements draft.  The aim of this draft is to provide a
	progress update to the Netmod WG concerning the YANG
	versioning design team discussions on potential solutions, and
	to hopefully provide sufficient information to allow the wider
	Netmod community to provide input into the direction of the
	YANG versioning design team.
      </t>
    </abstract>

  </front>
  <middle>
    <section anchor="terminology" title="Terminology and Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
        <xref target="RFC2119"/>.</t>
	<t>
	  This document also makes use of the terminology introduced in the YANG versioning requirements draft (REF REQUIRED).
	  In addition, this document introduces the following terminology:
        <list style="symbols">
          <t>bc: Used as an abbreviation for a backwards compatible change.</t>
	  <t>nbc: Used as an abbreviation for a non backwards compatible change.</t>
        </list>
      </t>
    </section>
    <section anchor="intro" title="Introduction">
      <t>This document mainly considers the types of different
      solution, along with any significant variants, that may be able
      to address the requirements in the YANG versioning requirements
      draft.</t>

      <t>It also considers secondary solutions that address some of
      the additional YANG versioning requirements.</t>

      <t>Finally, it lists some of the open issues that the YANG
      versioning design team are also considering.</t>

      <t>This draft represents work in progress, and should be treated
      as such.  In particular, it does not recommend any particular
      solution(s) at this point in time.  It is anticipated that a
      separate draft shall be written to describe the final solution
      proposed by the design team.</t>
    </section>
    <section anchor="background" title="Background">
      <t>
	Some members of the design team are authors of a potential
	solution draft to the YANG vesioning requirements.  The
	purpose of this document is to ensure that all reasonable
	solutions to the YANG versioning problem have been properly
	considered before converging on a single chosen solution.
      </t>
    </section>

    <section anchor="reqs" title="Summary of requirements">
      <t>The requirement themselves are documented in section 5 of
      XXX.  A shortened, non normative, summary of each of the
      requirements (using the same requirement numbers) is provided
      below to aid evaluation of the potential solutions.</t>
      <t>XXX - This will need to be updated with any changes in the
      requirements draft.</t>
      <t>
        <list style="Bullets">
              <t>Req 1.1 - MUST support nbc updates without breaking imports.</t>
              <t>Req 1.2 - MUST support nbc updates without breaking existing client code.</t>
              <t>Req 1.3 - MUST support import stmt restricted to only some revisions.</t>
              <t>Req 2.1 - MUST be able to determine if two arbitrary versions of any MODULE are unchanged, bc, or nbc.</t>
              <t>Req 2.1 - SHOULD be able to determine if two arbitrary versions of any DATA NODE are unchanged, bc, or nbc.</t>
              <t>Req 3.1 - MUST allow servers to support existing clients.</t>
	      <t>Req 3.2 - MUST allow for simultaneously support of clients using different (perhaps restricted) revisions.</t>
              <t>Req 4.1 - MUST provide way to indicate if deprecated nodes are implemented.</t>
	      <t>Req 4.2 - MUST be able to document reason for lifecycle changes, and possible alternative data nodes.</t>
	      <t>Req 4.3 - MUST be able to forewarn of future lifecycle changes.</t>
	      <t>Req 4.4 - SHOULD allow bugfixes to older revision of a module.</t>
              <t>Req 5.1 - MUST provide guidance on how to use the new scheme.</t>
	      <t>Req 5.2 - MUST provide, and document, an upgrade path from exising YANG/protocols.</t>
	      <t>Req 5.3 - MUST consider versioning impact on instance data.</t>
        </list>
      </t>
    </section>
    <section anchor="det_solutions" title="Potential solutions to core YANG versioning requirements">
      <t>
	This section considers solutions that are aimed at solving the
	main YANG versioning requirements.</t>
      <t>The solutions being considered are:
        <list style="numbers">
          <t>Module level 'major.minor.patch' semantic versioning</t>
	  <t>Module level 'release.major.minor.patch' versioning</t>
	  <t>Module level '(major.major).minor' semantic versioning</t>
	  <t>A tool based approach comparing YANG schema modules/trees</t>
          <t>Follow existing RFC 7950 rules</t>
        </list>
      </t>
      <section title="Module level 'major.minor.patch' semantic versioning">
	<t>This solution introduces a module level version number that
	adopts a subset of the semantic versioning rules published at
	semver.org.</t>
	<t>The key part of this solution is a version number that comprises
	three fields, 'major.minor.patch':
	  <list style="numbers">
	    <t>major - updated only when a non backwards compatible change is made</t>
	    <t>minor - updated only when a backwards compatible change is made</t>
	    <t>patch - updated only when a cosmetic change is made</t>
	  </list>
	</t>
	<t>When a field in the version number is incremented, all
	following fields are reset back to 0.  Major version number 0
	indicates that the module is not yet stable and allows non
	backwards compatible changes without requiring the major
	version number to be incremented (e.g., this would be used in
	IETF drafts before they become RFCs).</t>
	<t>If this solution is adopted, it is assumed that vendors
	would need to manage versioning of native YANG models
	independently of software release trains, and even then they
	would be limited in the scope of what changes are possible in
	an already shipped release, which is anticipated to not meet
	the business requirements of vendors.</t>
	<t>Solution advantages:
	<list style="numbers">
	  <t>Follows widely known semantic versioning rules.</t>
	  <t>Version number alone indicates whether 2 module revisions are backwards compatible.</t>
	  <t>Sufficient for most (but not necessarily all) YANG models developed by SDOs.</t>
	  <t>Matches the scheme being used by OpenConfig YANG models.</t>
        </list>
	</t>
	<t>Solution disadvantages:
	<list style="numbers">
	  <t>Does not fully support long lived vendor software release trains.</t>
	  <t>Does not necessarily allow for backwards compatible
	  changes (enhancements or bug fixes) in older releases.</t>
	  <t>Does not allow for non backwards compatible changes
	  (enhancements or bug fixes) in older releases.</t>
	  <t>The 'patch' field is not particularly useful for YANG modules
	  (which act like an API), since cosmetic changes are likely
	  to be rare.</t>
        </list>
	</t>
      </section>
      <section title="Module level 'release.major.minor.patch' partial semantic versioning">
	<t>This solution extends the semver 'major.minor.patch' version number scheme with an explicit software release positive integer field.</t>
	<t>The key part of this solution is a version number comprising four fields (release.major.minor.patch):
	  <list style="numbers">
	    <t>release - may be updated at any time (e.g. for a new major software release)</t>
	    <t>major - updated only when a non backwards compatible change is made</t>
	    <t>minor - updated only when a backwards compatible change is made</t>
	    <t>patch - updated only when a cosmetic change is made</t>
	  </list>
	</t>
	<t>When a field in the version number is incremented, all
	following fields are reset back to 0.  Release version number
	0 indicates that the version is not yet stable and non
	backwards compatible changes are allowed without incrementing
	the major version number.</t>
	<t>The assumption for this scheme is that the release number
	is always incremented for every major release, i.e. at any
	point where nbc changes may be required in an older
	release.</t>
	<t>Solution advantages:
	<list style="numbers">
	  <t>Supports long lived vendor software release trains.</t>
	  <t>Allows bc and nbc changes (enhancements or bug fixes) in older independent releases.</t>
	  <t>Probably sufficient for YANG models developed by both vendors and SDOs.</t>
        </list>
	</t>
	<t>Solution disadvantages:
	<list style="numbers">
	  <t>Release version field is incremented regardless of changes.</t>
	  <t>Version number is no longer an indicator of changes between 2 module revisions.</t>
	  <t>Differs from the scheme used by OpenConfig YANG models.</t>
        </list>
	</t>
	<t>Similar variants:
	<list>
	  <t>The 'release' field could be regarded as optional, and if
	  omitted, the version interpreted in the same way as the
	  module level 'major.minor.patch' semantic versioning
	  solution.</t>
	</list>
	</t>
      </section>
      <section title="Module level '(major.major).minor' semantic versioning">
	<t>This solution introduces a module level version number
	scheme, along the lines the Haskell Package Versioning Policy,
	but without the 'patch' field, that is not particularly useful
	in YANG module versioning.</t>
	<t>The key part of this solution is a version number
	comprising three fields '(major.major).minor':
	<list style="numbers">
	  <t>(major.major) - one of the two major fields is updated
	  only when a non backwards compatible change is made.</t>
	  <t>minor - updated only when a backwards compatible change
	  is made.</t>
	</list>
	</t>
	<t>When a field in the version number is incremented, all
	following fields (including the second 'major' field) are reset
	back to 0.  Major version number '0.x' indicates that the
	version is not yet stable.</t>
	<t>If this solution is adopted, then normally any non
	backwards compatible change would increment the first
	major version field, keeping the second major version for non
	backwards compatible changes within a software release (e.g. perhaps
	nbc bug fixes).</t>
	<t>Solution advantages:
	<list style="numbers">
	  <t>Version number alone indicates whether 2 module versions are backwards compatible (i.e. the key benefit of semver).</t>
	  <t>Supports long lived vendor release trains.</t>
	  <t>Allows for limited nbc changes (enhancements or bug fixes) in older releases.</t>
	  <t>Allows for some bc changes (enhancements or bug fixes) in older releases.</t>
	  <t>Probably sufficient for YANG models developed by both vendors and SDOs.</t>
	  <t>Probably allows for a strict interpretation of backwards compatibility in bug fixes.</t>
        </list>
	</t>
	<t>Solution disadvantages:
	<list style="numbers">
	  <t>Less common scheme could cause confusion with semver (but potentially alleviated by using a diffent syntax).</t>
	  <t>The scheme probably works best if YANG modules are versioned independently from software release.</t>
	  <t>Does not always allow bc changes (enhancements or bug fixes) in older releases.</t>
	  <t>Differs from the scheme used by OpenConfig YANG models.</t>
        </list>
	</t>
	<t>Similar variants:
	<list>
	  <t>A real, or decimal, number could be used as a single field to replace the two major version fields.</t>
	  <t>An alternative format for the version string could be used.</t>
	</list>
	</t>
      </section>
      <section title="A tool based approach comparing YANG schema modules/trees">
	<t>This solution relies on using tooling to compare either two
	YANG modules, or two YANG schema trees to identify any changes
	between the two modules that do not conform to RFC 7950
	section 11 backwards compatibility rules.</t>
	<t>Not all differences between two YANG statements in
	differente module versions can easily be identified as
	backwards compatible or not (for example changes in
	description, pattern statements, must or when statements may
	be hard to check).  If a tool is unable to check then it would
	have to flag the change as potentially being non backwards
	compatible, potentially reporting many false positives.</t>
	<t>To mitigate this, it is proposed that this solution also
	introduces a new YANG extension statement to indicate that a
	change is backwards compatible.</t>
	<t>When comparing a module schema, a tool would also be able
	to take into account enabled features, deviations, and the
	subset of the schema being used by the client.  This would
	allow a tooling based approach to give a more accurate answer
	as to whether a client would be affected when upgrading
	between two software versions.</t>
	<t>Solution advantages:
	<list style="numbers">
	  <t>Gives the most accurate answer that works in all cases.</t>
        </list>
	</t>
	<t>Solution disadvantages:
	<list style="numbers">
	  <t>Cannot easily check whether two modules are compatible
	  just by looking at them.  Probably needs to be used in
	  conjunction with a module level versioning scheme.</t>
	  <t>Differs from the scheme used by OpenConfig YANG models.</t>
        </list>
	</t>
      </section>
      <section title="Follow existing RFC 7950 rules">
	<t>The final choice is to decide that the existing
	mechnaism described in RFC 7950, that disallows any non
	backwards compatible changes in a given model, is the best way
	forward.  Instead of making a nbc chagne, the modeller can
	introduce new parallel nodes, and deprecate the existing nodes
	within the same module.  Alternatively an entirely new module,
	with a separate name and namespace can be introduced. </t>
	<t>As a solution, this cannot meet all of the requirements
	stated in the requirements draft.</t>
	<t>If this solution was sufficent, then the YANG versioning
	design team would not have been formed.  However, some vendors
	are pragmatically ignoring the strict YANG module update rules
	(e.g. for vendor modules).</t>
	<t>Solution advantages:
	<list style="numbers">
	   <t>No significant change in YANG language semantics
	   required.  Changes, or perhaps extensions, could be made to
	   the YANG language to address some of other requirements
	   that have independent solutions.</t>
        </list>
	</t>
	<t>Solution disadvantages:
	<list style="numbers">
	   <t>If an nbc has to be made (even for a minor feature)
	   then there is a high impact to all clients using the
	   module, servers implementing the module, and other YANG
	   modules that import from the module.  This impact would be
	   particularly acute for a core YANG module that is
	   being updated in an nbc way, that is imported by many other
	   YANG modules.  Hence, choosing this solution really means
	   that there can be no nbc changes to a module unless the
	   module is being restructured in a major way when a separate
	   name for the module makes sense regardless.</t>
	   <t>Seems to make standardization slow because participants
	   are seeminly try harder to get the perfect model first
	   because the cost of having to change it seems so high.</t>
	   <t>Old, dead definitions can potentially never be removed
	   from a module.</t>
	   <t>Does not work well for vendor generated YANG models,
	   since they cannot easily have the level or control and
	   stability requried for it to never change.</t>
	   <t>Does not solve the problem where deviations are used to
	   introduce nbc changes.</t>
	   <t>Introduces a problem where a single underlying property
	   is represented by two (or more) independent data nodes in
	   the same schema.  There does not appear to be a clean
	   solution on how to manage the relationship between these
	   two nodes (e.g. if both an old and new client are
	   interacting with a server).  Other solutions have the
	   potential of handling this better.</t>
        </list></t>

	<t>Variants:
	<list>
	<t>One variant of this solution is to agree on the rules for
	making bugfixes to published YANG modules, and determine
	whether that requires any changes to the section 11 text in
	RFC 950.</t>
	</list>
	</t>
      </section>
      <section title="Solutions to related YANG versioning issues">
      <t>These partial solutions address particular point
      requirements.  The partial solutions are:
        <list style="numbers">
          <t>Deprecated flag - Add a flag to YANG library to indicate
          whether deprecated nodes are implemented or not.</t>
          <t>Redefine deprecated stmt - Change the definition of the
          YANG deprecated statement to indicate that deprecated data
          nodes must be implemented, or otherwise deviated.</t>
          <t>Status description - Allow the "description" statement
          under the YANG "status" statement to document data node
          lifecycle, and allow for forward guidance.</t>
	  <t>Alternative node path - Introduce a new YANG statement to
	  provide an alternative path for a deprecated, or obsolete,
	  data node.</t>
        </list>
      </t>
      </section>
    </section>
    <section anchor="questions" title="Open Questions">
      <t>This section lists some of the open questions that the design
      team is still grappling with.</t>
      <section anchor="q1" title="Is YANG module revision date preserved?">
	<t>With the introduction of the new versioning scheme, should
	every YANG module still have a revision statement, or is that
	entirely superceded by a new version statement?
	</t>
	<t>If preserved, then is there a requirement that all unique
	YANG modules MUST have a unique revision date?</t>
	<t>If preserved, and unique, then is it acceptable to break
	the existing monotonically increasing property of the current
	module revision date?</t>
      </section>
      <section anchor="q2" title="Do YANG update rules allow for bugfixes?">
	<t>Does YANG (RFC 7950) section 11 allow nbc bugfixes to
	existing models, and if so, are there any limits as to what
	form those bugfixes can take, or are these strictly prohibited
	by the module update rules?</t>
      </section>
      <section anchor="q3" title="Does one size fit all?">
	<t>Potentially different types of YANG modules may want to follow different versioning semantics.</t>
	<t>E.g. it may be right that standardized YANG modules are very slow changing and conservative in their backwards compatibility</t>
	<t>Conversely, it is potentially more pragmatic that vendor YANG modules need to change in more significant ways mirroring changes in underlying implementations or hardware.</t>
      </section>
      <section anchor="q4" title="Should vendors we allowed to version YANG modules as part of a release train?">
	<t>Some of the solutions described in this document probably
	require vendors to version native YANG modules outside of
	release trains, which is likely to be different to how
	some vendors are managing this today.  Is it a reasonable
	contraint to put on vendors that they MUST version YANG
	modules outside of a release train to provide a cleaner
	version history?</t>
      </section>
    </section>
    <section anchor="contributor" title="Contributors">
      <t>This document grew out of the YANG module versioning design team that started after IETF 101. The following people are members of that design team and have contributed to defining the problem and specifying the requirements:</t>
      <t>
        <list style="symbols">
          <t>Balazs Lengyel</t>
          <t>Benoit Claise</t>
          <t>Ebben Aries</t>
	  <t>Jason Sterne</t>
          <t>Joe Clarke</t>
          <t>Juergen Schoenwaelder</t>
          <t>Mahesh Jethanandani</t>
          <t>Michael (Wangzitao)</t>
          <t>Qin Wu</t>
          <t>Reshad Rahman</t>
          <t>Rob Wilton</t>
	  <t>Susan Hares</t>
        </list>
      </t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>
        The document does not define any new protocol or data model. There is no security impact.
      </t>
    </section>
    <section anchor="iana" title="IANA Considerations">
      <t>None</t>
    </section>

  </middle>
  <?rfc needLines="20"?>
  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.7950"?>
      <?rfc include="reference.RFC.2119"?>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.8049"?>
      <?rfc include="reference.RFC.8199"?>
      <?rfc include="reference.RFC.8299"?>
    </references>
    <?rfc needLines="100"?>
  </back>
</rfc>

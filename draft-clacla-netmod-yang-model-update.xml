<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC6020 SYSTEM "reference.RFC.6020.xml">
<!ENTITY RFC7895 SYSTEM "reference.RFC.7895.xml">
<!ENTITY RFC7950 SYSTEM "reference.RFC.7950.xml">
<!ENTITY RFC8199 SYSTEM "reference.RFC.8199.xml">
<!ENTITY RFC8199 SYSTEM "reference.RFC.8299.xml">
<!ENTITY OPENCONFIG-YANG-CATALOG SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.openconfig-netmod-model-catalog.xml">
<!ENTITY CLAISE-SEMVER "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.claise-semver.xml">
<!ENTITY CLAISE-SEMVER "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.netconf-rfc7895bis">
<!ENTITY OPENCONFIG-YANG-CATALOG SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.openconfig-netmod-model-catalog.xml">
<!ENTITY CLACLA-NETMOD-MODEL-CATALOG "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.clacla-netmod-model-catalog.xml">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc updates="7950" category="std" ipr="trust200902" docName="draft-clacla-netmod-yang-model-update-05">
<front>
<title abbrev="YANG Catalog">New YANG Module Update Procedure</title>

<author initials="B." surname="Claise" fullname="Benoit Claise">
  <organization abbrev="Cisco Systems, Inc.">
    Cisco Systems, Inc.
 </organization>
  <address>
    <postal>
<street>De Kleetlaan 6a b1</street>
<city>1831 Diegem</city>
<country>Belgium</country>
    </postal>
    <phone>+32 2 704 5622</phone>
    <email>bclaise@cisco.com</email>
  </address>
</author>

  <author initials="J." surname="Clarke" fullname="Joe Clarke">
    <organization>Cisco Systems, Inc.</organization>
    <address>
      <postal>
        <street>7200-12 Kit Creek Rd</street>
        <city>Research Triangle Park</city>
        <region>North Carolina</region>
        <country>United States of America</country>
      </postal>
      <phone>+1-919-392-2867</phone>
      <email>jclarke@cisco.com</email>
    </address>
  </author>

  <author initials="B." surname="Lengyel" fullname="Balazs Lengyel">
    <organization abbrev="Ericsson"> Ericsson </organization>
    <address>
      <postal>
        <street>Magyar Tudosok Korutja</street>
        <city>1117 Budapest</city>
        <country>Hungary</country>
      </postal>
      <phone>+36-70-330-7909</phone>
      <email>balazs.lengyel@ericsson.com</email>
    </address>
  </author>

<author initials="K." surname="D'Souza" fullname="Kevin D'Souza">
  <organization>AT&amp;T</organization>
  <address>
    <postal>
<street>200 S. Laurel Ave</street>
<city>Middletown</city>
<region>NJ</region>
<country>United States of America</country>
    </postal>
    <phone></phone>
    <email>kd6913@att.com</email>
  </address>
</author>

<date/>
<abstract>
  <t>
  This document specifies a new YANG module update procedure in case of backward-incompatible
  changes, as an alternative proposal to the YANG 1.1 specifications. This document updates RFC 7950.
  </t>
</abstract>
</front>
<middle>
<section anchor="intro" title="Introduction">
<t>
The YANG data modeling language <xref target="RFC7950"/> specifies strict
rules for updating YANG modules (see section 11 "Updating a Module").
Citing a few of the relevant rules:

<list style="numbers">
<t>
   "As experience is gained with a module, it may be desirable to revise
   that module.  However, changes to published modules are not allowed
   if they have any potential to cause interoperability problems between
   a client using an original specification and a server using an
   updated specification."
</t>
<t>"Note that definitions contained in a module are available to be
   imported by any other module and are referenced in "import"
   statements via the module name.  Thus, a module name MUST NOT be
   changed.  Furthermore, the "namespace" statement MUST NOT be changed,
   since all XML elements are qualified by the namespace."
</t>
<t>"Otherwise, if the semantics of any previous definition are changed
   (i.e., if a non-editorial change is made to any definition other than
   those specifically allowed above), then this MUST be achieved by a
   new definition with a new identifier."
</t>
<t>
    "deprecated indicates an obsolete definition, but it permits
      new/continued implementation in order to foster interoperability
      with older/existing implementations."
</t>
</list>

What are the consequences?

<list style="numbers">
<t>
   If a YANG module is intended to update another YANG module, the module name should not be
   changed as it will break existing tooling and code by changing imports statements,
   service composition at the orchestration layer, general network management applications, etc.
</t>
<t>
   When the same YANG module name is kept, its new revision must be updated
   in a backward-compatible way.
</t>
<t>
    While most of the non-backward compatible changes are prohibited, a client still does not know if a
    changed module is backward compatible, as a server may remove parts of a module after
    marking it deprecated or obsolete.
</t>
</list>
</t>
<t>
  This document specifies a new YANG module update procedure in case of backward-incompatible
  changes, as an alternative proposal to the YANG 1.1 specifications. This document updates RFC 7950.
</t>
<t>
  This document does not address the potential need of an automatic way to discover that a YANG-MODULE-B
  obsoletes YANG-MODULE-A, so that YANG-MODULE-A should not be given any attention. This problem is
  currently solved by RFC obsolete tag as a level of indirection between the YANG modules.
</t>
</section>

<section anchor="how_is_YANG_used_today" title="How is YANG Used Today">
    <t>
    TO DO: this is not a complete section, but only the starting point. We must explain how a module change
	propagates into two dimensions: 1. the import and deviation. 2. the service composition via controller and
	orchestrator.
	We must show all all the scripts are affected and that minimizing the script changes should be a goal
    </t>
	<t>
    Let's assume for a moment that we change the name of a YANG module when making a backwards-incompatible change, with the specific example of
    ietf-routing, which some propose to update to ietf-routing-2.  <xref target="yangcatalog"/> provides tooling
    that shows the interdependencies of YANG modules.
    </t>
    <t>
    Here are the over 30 modules that depend on ietf-routing
    <eref target="https://www.yangcatalog.org/yang-search/impact_analysis.php?modules[]=ietf-routing&amp;recurse=0&amp;rfcs=1&amp;show_subm=1&amp;show_dir=dependents"/>.
    </t>
    <t>
    Let's look at the difference for ietf-routing-2:
    <eref target="https://www.yangcatalog.org/yang-search/impact_analysis.php?modules[]=ietf-routing-2&amp;recurse=0&amp;rfcs=1&amp;show_subm=1&amp;show_dir=dependents"/>.
    </t>
    <t>
    Changing the module name from ietf-routing to ietf-routing-2 implies that the we have to warn all draft authors of
    ietf-routing YANG dependent modules. First, to make sure they are aware of ietf-routing-2 (publishing a RFC8022bis
    mentioning in the module description that this module is not compatible with the NMDA architecture, and providing
    a pointer to ietf-routing-2 requires manual, tedius work). And second, to ask them to change
    their import (or service composition) to ietf-routing-2. Hopefully, in the ietf-routing case, most dependent YANG
    modules are part of the IETF, so the communication is a manageable.
    For the already existing dependent vendor modules the problem is worse.  And then there are network management applications
    that may already be using ietf-routing that would require new code to handle ietf-routing-2.
    </t>
    <t>
    Changing the ietf-interfaces YANG module name would be a different challenge, as it's used throughout the industry:
    <eref target="https://www.yangcatalog.org/yang-search/impact_analysis.php?modules[]=ietf-interfaces&amp;recurse=0&amp;rfcs=1&amp;show_subm=1&amp;show_dir=dependents"/>
    </t>
      <section title="Client Behavoir - Need to Check Revisions and More">
        <t>
          When a client contacts a YANG server,
it first needs to read data from ietf-yang-library including supported modules, their
revisions, deviations, and supported features. While theoretically just the
module name and the path would identify a YANG schema node, in practice a schema
node MAY NOT be available if
          <list style="symbols">
            <t>it was introduced or modified by a newer revision of the YANG module than
            what is supported by the server</t>
            <t>a feature covering it is not supported</t>
            <t>a deviation removes it</t>
          </list>
So even if a YANG module is developed in a fully compatible way the client must check
at least the three items above before it can reliably use a schema node.
        </t>
      </section>
    </section>


  <section anchor="problems" title="The Problems">
  <t>
  This section lists a series of problems, which
  leads to the solution in the next section.
  </t>

  <section anchor="slow_standardization" title="Slow Standardization">
    <t>
    The points made in the introduction lead to the logical conclusion that the
    standardized YANG modules have to be perfect on day one (at least the structure and meaning), which in
    turn might explain why IETF YANG modules take so long to standardize. Shooting for
    perfection is obviously a noble goal, but if the perfect standard
    comes too late, it doesn't help the industry.
    </t>
  </section>

  <section anchor="some_YANG_modules_are_not_backward_compatible" title="Some YANG Modules Are Not Backward Compatible">
    <t>
    As we learn from our mistakes, we're going to face more and more backward-incompatible
    YANG modules. An example is the YANG data model for L3VPN service delivery <xref target="RFC8049"/>,
    which, based on implementation experience, has been updated in a backward-incompatible
    way by <xref target="RFC8299"/>.
    </t>
    <t>
    While Standards Development Organization (SDO) YANG modules are obviously better
    for the industry, we must recognize that many YANG modules are actually generated
    YANG modules (for example, from internal databases), also known as native YANG modules,
    or vendor modules <xref target="RFC8199"/>. From time to time, the new YANG modules are not
    backward-compatible.
    </t>
    <t>
      Old module parts that are no longer needed, no longer supported, or are
not used by consumers need to be removed from modules. It is often hard
to decide which parts are no longer needed/used; still the need and
practice of removing old parts exist. While it is rare in standard modules it
is more common in vendor YANG modules where the usage of modules is more controlled.
    </t>
    <t>
      The problems described in <xref target='clear_indication_of_node_support'/>
      may also result in incompatible changes.
    </t>
    <t>
    In such cases, it would be better to indicate how backward-compatible a given YANG module
    actually is.
    </t>
    <t>As modules are sometimes updated in an incompatible way the current
    assumption that once a YANG module is defined all further revisions can be freely
    used as they are compatible is not valid.</t>
  </section>

  <section title="Non-Backward Compatible Errors">
      <t>
          Sometimes small errors force us to make non-backward compatible updates. As an example imagine that we have
          a string with a complex pattern (e.g., an IP address). Let's assume the initial pattern
          incorrectly allows IP addresses to start with 355. In the next version this is corrected to
          disallow addresses starting with 355. Formally this is an non-backward compatible change as the value space
          of the string is decreased. In reality an IP address and the implementation behind it
          was never capable of handling an address starting with 355. So practically this is a backward compatible change,
          just like a correction of the description statement. Still current YANG rules would force
          a module name change.
      </t>
  </section>
<!--
EDITOR NOTE: I don't think we need this justification anymore.

  <section anchor="a_zoo_of_yang_modules" title="A Zoo of YANG Modules">
    <t>
    Even if we focus on the IETF, we have to observe that many SDOs, opensource fora,
    and vendors develop YANG modules.
    This should be considered a success for an IETF developed technology. However, the
    operators are faced with this problem: how to select the YANG modules to take
    into account for their service developments.
    </t>
    <t>
    The site <eref target="https://www.yangcatalog.org"/> (and the YANG catalog that it provides:
    YANG module for yangcatalog.org, <xref target="I-D.clacla-netmod-model-catalog"/>) is an attempt to
    become a reference for all YANG modules available in the industry, for both YANG developers
    to search on what exists already) and for operators (to discover the more mature YANG models
    to automate services). This YANG catalog should not only contain pointers to the YANG modules
    themselves, but also contain metadata related to those YANG modules: What is the module type
    (service model or not?); what is the maturity level? (e.g., for the IETF: is this an RFC, a
    working group document or an individual draft?); is this module implemented?; who is the contact?;
    is there open-source code available? And we expect many more in the future. The industry has
    begun to understand that the metadata related to YANG models become equally important as the
    YANG models themselves.
    </t>
    <t>
    The yangcatalog.org instantiation of the catalog provides a means for module authors and
    vendors implementing modules to upload their metadata, which is then searchable via an API,
    as well as using a variety of web-based tools.  The instructions for contributing and searching
    for metadata can be found at <eref target="https://www.yangcatalog.org/contribute.php"/>.
    </t>
    <t>
    The issue is actually the number of YANG modules the operators are offered. At the time of
    writing this document, the number of unique YANG modules in the catalog is exactly 2596 (and
    that number keeps growing), while the IETF has standardized or is busy standardizing a small
    subset of those. Therefore, it's important to distinguish the relevant YANG modules with the
    pack and to understand the relationship between the YANG modules.
    </t>
  </section>

  <section anchor="yang_modules_obsolete_relationship" title="YANG Modules Obsolete Relationship">
    <t>
    So the operators use the yangcatalog.org to discover which YANG modules they can use NOW.
    They base their selection not only on the YANG module content, but also on the related
    metadata. When faced with the zoo of the YANG modules, it's difficult to understand the
    relationship between YANG modules. As an example: how could an operator discover that
    YANG-MODULE-B obsoletes YANG-MODULE-A? Indeed, both have different YANG module names.
    The only available information is an "obsolete" tag in the published RFC containing YANG-MODULE-B:
    this tag would point to YANG-MODULE-A. In the world of automation, going through a
    published RFC as a level of indirection to understand the YANG module obsolete relationship
    is a non-starter. Food for thought: the IETF should stop thinking that the metric for success
    is an RFC number, as opposed to the contained YANG module(s).
    </t>
    <t>
    We need an automatic way to discover that a YANG-MODULE-B obsoletes YANG-MODULE-A, so that
    YANG-MODULE-A should not be given any attention.
    </t>
    <t>

    The following example is not an automatic way.
    </t>
    <figure>
       <artwork>
    description
        "This YANG module defines a generic service configuration
        model for Layer 3 VPNs. This model is common across all
        vendor implementations. This obsoletes the RFC8049 YANG
        module, ietf-l3vpn-svc@2017-01-2";
    revision 2017-09-14 {
        description
        "First revision of RFC8049.";
        reference
        "RFC xxxx: YANG Data Model for L3VPN Service Delivery";
       </artwork>
    </figure>
    <t>
    Along the same lines, while going through an out-of-band tool such as the yangcatalog.org in order
    to discover the obsolete relationship is a possible automatic way, it is not ideal.
    </t>
  </section>
-->


  <section title="No way to easily decide whether a change is Backward Compatible">
      <t>
           A management system, SDN controller or any other user of a module should be
capable of easily determining the compatibility between two module versions.
Higher level logic for a network function,
something that can not be implemented in a purely model driven way, is always
dependent on a specific version of the module. If the client finds that
the module has been updated on the network node, it has to decide if it tries to
handle it as it handled the previous version of the model or if it just stops, to
avoid problems. To make this decision the client needs to know if the module
was updated in a backward compatible way or not.
</t>
<t>
This is not possible to decide today because of the following:
<list style="symbols">
    <t>It is possible to change the semantic behavior of a data node, action or rpc
while the YANG definition does not change (with the possible exception of the
description statement). In such a case it is impossible to
determine whether the change is backward compatible just by looking at the YANG statements.
Its only the human model designer that
can decide.</t>
<t>Problems with the deprecated and obsolete status statement, <xref target='clear_indication_of_node_support'/></t>
<t>Modelers might decide to violate  YANG 1.1 update rules for some of the reasons above</t>
</list>
Finding status changes or violations of update rules need a line by line
comparision of the old and new modules, no easy task.
      </t>
  </section>

  <section title="No good way to specify which module revision to import">
    <t>
      If a module (MOD-A) is imported by another one (MOD-B) the importer may specify
which revision must be imported. Even if MOD-A is developed in
backward-compatible way not all revisions will be suitable,
e.g., a new MOD-B might need the newest MOD-A. However, both specifying or
omitting the revision date for import leads to problems.
    </t>
    <t>
If the import by revision-date is specified
    <list  style="symbols">
      <t>
        If corrections are made to MOD-A these would not have any effect as the
import’s revision date would still point to the un-corrected earlier YANG module revision.
      </t>
      <t>
        If MOD-A is developed in a backward-compatible way because another importer (MOD-C)
needs some functionality, the new MOD-A could be used by MOD-B, but specifying
the exact import revision-date prevents this. This will force the implementers to
import two different revisions of MOD-A, forcing them to maintain old MOD-A
revisions unnecessarily.
      </t>
      <t>
        If multiple modules import different revisions of MOD-A the human user will
need to understand the subtle differences between the different revisions.
Small differences would easily lead to operator mistakes as the operator will
rarely check the documentation.
      </t>
      <t>
        Tooling/SW is often not prepared to handle multiple revisions of the same YAM.
      </t>
    </list>
    </t>
    <t>
If the import revision-date is not specified
    <list  style="symbols">
      <t>
        any revision of MOD-A may be used including unsuitable ones. Older revisions
may be lacking functionality MOD-B needs. Newer MOD-A revisions may obsolete
definitions used by MOD-B in which case these must not be used by MOD-B anymore.
      </t>
      <t>
        As it is not specified which revisions of MOD-A
are suitable for MOD-B. The problem has to solved on a case by case basis
studying all the details of MOD-A and MOD-B which is a big work.
      </t>
    </list>
    </t>
  </section>

    <section title="Early Warning about Removal">
      <t>
        If a schema part is considered old/bad we need to be able to give
advance warning that it will be removed.  As this is an advance
warning the part must still be present and usable in the current
revision; however, it will be removed in one of the next revisions.
The  deprecated statement cannot be reliably used for this purpose
both because deprecated nodes may not be implemented and also there
is no mandate that text be provided explaining the deprecation.
    </t>
    <t>
We need the advance warning to allow users of the module time
to plan/execute migration away from the deprecated functionality.
Deprecation should be accompanied by information whether the
functionality will just disappear or that there is an alternative,
possibly more advanced solution that should be used.
    </t>
    <t>
Vendors use such warnings often, but the NMDA related redesign of
IETF modules is also an example where it would be useful for IETF. As
another example, see the usage of deprecated in the Java programing
language.
      </t>
    </section>
  <section title="Clear Indication of Node Support" anchor="clear_indication_of_node_support">
      <t>
      The current definition of deprecated and obsolete in <xref target="RFC7950"/> (as quoted below) is problematic and should be
corrected.
<list style="symbols">
<t>"deprecated" indicates an obsolete definition, but it permits
      new/continued implementation in order to foster interoperability
      with older/existing implementations.</t>
<t>"obsolete" means that the definition is obsolete and SHOULD NOT be
      implemented and/or can be removed from implementations.</t>
</list>
</t>
<t>YANG is considered an interface contract
between the server and the client.  The current definitions of
deprecated and obsolete mean that a schema node that is either deprecated or
obsolete may or may not be implemented. The client has no way to
find out which is the case except for by trying to write or read data at
the leaf in question. This probing would need to be done for
each separate data-node, which is not a trivial thing to do.  This "may or
may not" is unacceptable in a contract.  In effect, this works as if
there would be an if-feature statement on each deprecated schema node
where the server does not advertise whether the feature is supported or
not.  Why is it not advertised?
      </t>
  </section>

</section>

<section anchor="the_requirements" title="The Requirements">

  <section title="Need to Allow Non-Backward Compatible changes">
      <t>
          As described in the previous sections, there is a need to allow non-backward compatible changes
          without changing a module's name. This would avoid many of the problems stated above.  Allowing non-backward compatible changes to happen without a module
      name change will decrease the number of separate modules to handle and will make it a trivial
      task to track these non-backward compatible changes.</t>

      <!-- EDITOR QUESTION: Do we want to say anything about creating a new module?  That seems to me to be understood. -->
  </section>

</section>

<section anchor="the_solution" title="The Solution">
  <t>
  The solution is composed of five parts:
       <list style="numbers">
       <t>A semantic versioning YANG extension, along with an optional additional check that validates
	      the semantic versioning from a syntactic point of view, which can either assist in
		  determining the correct semantic versioning values, or which can help in determining
		  the values for YANG modules that don't support this extension. </t>
       <t>The import by version statement"</t>
       <t>Updates to the YANG 1.1 module update rules</t>
	   <t>Updates to ietf-yang-library</t>
       <t>The deprecated and obsolotes Reason"</t>
     </list>
  </t>

  <section anchor="semver_semantic_versioning" title="Semantic Versioning">
    <section anchor="semantic_versioning_as_set_by_the_YANG_module_designer" title="Semantic Versioning, As Set by the YANG Module Designer">
    <t>
    The semantic versioning solution proposed here has already been proposed in
    <xref target="I-D.openconfig-netmod-model-catalog "/> (included here with
    the authors' permission) which itself is based on <xref target="openconfigsemver"/>.
    The goal is to indicate the YANG module backwards (in)compatibility, following semver.org
    semantic versioning <xref target="semver"/>:
    </t>
    <t>
     "The SEMVER version number for the module is introduced. This is
         expressed as a semantic version number of the form: x.y.z
     <list style="symbols">
       <t>x is the MAJOR version. It is incremented when the new version of the specification is
           incompatible with previous versions.</t>
       <t>y is the MINOR version. It is incremented when new functionality is added in a manner
            that is backward-compatible with previous versions.</t>
       <t>z is the PATCH version. It is incremented
            when bug fixes are made in a backward-compatible manner."</t>
     </list>
    </t>
	<t>
    The semantic version value is set by the YANG module developer at the design and implementation times.
    Along these lines, we propose the following YANG 1.1 extension for a more generic
      semantic version.  The formal definition is found at the end of this document.</t>
    <figure>
      <artwork>
        extension module-version {
            argument semver;
        }
      </artwork>
    </figure>
    <t>
    The extension would typically be used this way:
    </t>
    <figure>
       <artwork>
    module yang-module-name {

      namespace "name-space";
      prefix "prefix-name";

      import ietf-semver { prefix "semver"; }

      description
        "to be completed";


      revision 2017-10-30 {
        description
          "Change the module structure";
        semver:module-version "2.0.0";
      }

      revision 2017-07-30 {
        description
          "Added new feature XXX";
        semver:module-version "1.2.0";
      }

      revision 2017-04-03 {
        description
          "Update copyright notice.";
        semver:module-version "1.0.1";
      }

      revision 2017-04-03 {
        description
          "First release version.";
        semver:module-version "1.0.0";
      }

      revision 2017-01-26 {
        description
          "Initial module for inet types";
        semver:module-version "0.1.0";
      }


      //YANG module definition starts here
       </artwork>
    </figure>

	<t>
    See also "Semantic Versioning and Structure for IETF Specifications" <xref target="I-D.claise-semver"/> for a mechanism
    to combine the semantic versioning, the GitHub tools, and a potential change to the IETF process.
    </t>
  </section>
  <section anchor="the_derived_semantic_versioning" title="The Derived Semantic Version">
    <t>
      If an explicitly defined semantic version is not available in the YANG module, it is possible to
	  algoritmically calculate a derived semantic version. This can be used for modules not containing
	  a definitive semantic-version as defined in this document or as a starting value when specifying
	  the definitive semantic-version. Be aware that this algorithm may sometimes incorrectly classify
	  changes between the categories non-compatible, compatible or error-correction.
	</t>
  </section>
  <section anchor="implementation_experience" title="Implementation Experience">
   <t>
   <xref target="yangcatalog"/> uses the pyang utility to calculate the derived-semantic-version for all of the modules
   contained within the catalog.  <xref target="yangcatalog"/> contains many revisions of the same module
   in order to provide its derived-semantic-version for module consumers to know what has changed between
   revisions of the same module.
   </t>
   <t>
   Two distinct leafs in the YANG module <xref target="I-D.clacla-netmod-model-catalog"/> contain this semver notation:
   </t>
   <t>
     <list style="symbols">
       <t>the semantic-version leaf contains the value embedded within a YANG module
           (if it is available).
       </t>
       <t>the derived-semantic-version leaf is established by examining the
          the YANG module themselves.  As such derived-semantic-version only
          takes syntax into account as opposed to the meaning of various elements
          when it computes the semantic version.</t>

       <t>The algorithm used to produce the derived-semantic-version is as follows:
          <list style="numbers">
            <t>Order all modules of the same name by revision from oldest to newest.
            Include module revisions that are not available, but which are defined in the revision statements in one of the available module versions. </t>
            <t>If module A, revision N+1 has failed compilation, bump its derived semantic MAJOR version.
            For unavailable module versions assume non-backward compatible changes were done., thus bump its derived semantic MAJOR version.</t>
            <t>Else, run "pyang --check-update-from" on module A, revision N and revision N+1 to see if backward-incompatible changes exist.</t>
            <t>If backward-incompatible changes exist, bump module A, revision N+1's derived MAJOR semantic version.</t>
            <t>If no backward-incompatible changes exist, compare the pyang trees of module A, revision N and revision N+1.</t>
            <t>If there are structural differences (e.g., new nodes), bump module A, revision N+1's derived MINOR semantic version.</t>
            <t>If no structural differences exist, bump module A, revision N+1's derived PATCH semantic version.</t>
          </list>
        </t>
   </list>
   </t>
   <t>
     The pyang utility checks many of the points listed in section 11 of <xref target="RFC7950"/> for known module incompatibilities.
     While this approach is a good way to programmatically obtain a semantic version number, it does not address all cases
     whereby a major version number might need to be increased.  For example, a node may have the same name and same type, but
     its meaning may change from one revision of a module to another.  This represents a semantic change that breaks backwards
     compatibility, but the above algorithm would not find it.  Therefore, additional, sometimes manual, rigor must be done
     to ensure a proper version is chosen for a given module revision.
   </t>
  </section>
</section>

  <section title="Import by Semantic Version" anchor="import_semver">
      <t>
      If a module is imported by another one, it is usually not specified which
      revision of the imported module should be used. However, not all revisions
      may be acceptable. Today YANG 1.1 allows one to specify the revision date of the
      imported module, but that is too specific, as even a small spelling
      correction of the imported module results in a change to its revision date,
      thus making the module revision ineligible for import.
      </t><t>
      Using semantic versioning to indicate the acceptable imported module versions
      is much more flexible.  For example:
      <list style="symbols">
          <t>Only a module of a specific MAJOR version is acceptable.  All MINOR and PATCH versions
            can also be imported.</t>
          <t>A module at a specific MAJOR version or higher is acceptable.</t>
          <t>A module at a specific MAJOR.MINOR version is acceptable.  All PATCH versions
            can also be imported.</t>
          <t>A module within a certain range of versions are acceptable.  For example, in this
            case, a module between version 1.0.0 (inclusive) and 3.0.0 (exclusive) are acceptable.</t>
      </list>
       </t>

       <t>The ietf-semver module provides another extension, import-versions that is a child of
         import and specifies the rules for an acceptable set of versions of the given module.
         The structure of this extension is specified as follows:</t>

      <t>TODO: How to specify this? One thought is below, not fully formalized as this
        should be discussed further.  Note: while this uses a comma to separate discrete versions,
        we could instead allow for this to be specified multiple times.</t>

       <figure>
         <artwork><![CDATA[
[\[(]X[.Y[.Z]][-[X[.Y[.X]]][\])]][,...]

Where the first character MAY be a '[' or '(' to indicate at least inclusive and at least
 exclusive (respectively).  If this is omitted, a full semantic version must be specified
 and the import will only support this one version.

The following version, if specified with a '[' or '(' indicates the lower bound.  This can
 be a full semantic version or a MAJOR only or MAJOR.MINOR only.

The '-', if specified, is a literal hyphen indicating a range will be specified.  If the second portion
 of the import-versions clause is omitted, then there is no upper bound on what will be considered
 an acceptable imported version.

After the '-' the upper bound semantic version (or part thereof) follows.

After the upper bound version, one of ']' or ')' MUST follow to indicate whether this limit is inclusive
 or exclusive of the upper bound respectively.

Finally, a literal comma (',') MAY be specified with additional ranges.  Each range is taken as a logical
 OR.
          ]]>
        </artwork>
      </figure>

      <t>For example:</t>

      <figure>
        <artwork>
import example-module {
  semver:import-versions "[1.0.0-3.0.0)";
  // All versions between 1.0.0 (inclusive) and 3.0.0 (exclusive) are acceptable.
}

import example-module {
  semver:import-versions "[2-5]";
  // All versions between 2.0.0 (inclusive) and 5.y.z (inclusive) where y and z are
  // any value for MINOR and PATCH versions.
}

import example-module {
  semver:import-versions "[1.5-2.0.0),[2.5";
  // All versions between 1.5.0 (inclusive) and 2.0.0 (exclusive) as well as all versions
  // greater than 2.5 (inclusive).  In this manner, if 2.0 was branched from 1.4, and a
  // new feature was added into 1.5, all versions of 1.x.x starting at 1.5 are allowed,
  // but the feature was not merged into 2.y.z until 2.5.0.
}

import example-module {
  semver:import-versions "[1";
  // All versions greater than MAJOR version 1 are acceptable.  This includes any
  // MINOR or PATCH versions.
}

import example-module {
  semver:import-versions "1.0.0";
  // Only version 1.0.0 is acceptable (this mimics what exists with import by revision).
}

import example-module {
  semver:import-versions "[1.1-2)"";
  // All versions greater than 1.1 (inclusive, and including all PATCH versions off of 1.1)
  // up to MAJOR version 2 (exclusive) are acceptable.
}

import example-module {
  semver:import-versions "[1.1-2),[3";
  // All versions greater than 1.1 (inclusive, and including all PATCH versions off of 1.1)
  // up to MAJOR version 2 (exclusive), as well as all versions greater than MAJOR version 3
  // (inclusive) are acceptable.
}

import example-module {
  semver:import-versions "[1.1-2),[3.0.0";
  // This is equivalent to the example above, simply indicating that a partial semantic version
  // assumes all missing components are 0.
}
        </artwork>
      </figure>

       <t>
       The import statement SHOULD include a semver:import-versions statement and MUST NOT
       include a revision statement.  An import statement MUST NOT contain both a
       semver:import-versions and a revision substatement.  The use of the revision
       substatement for import should be discouraged.
      </t>
</section>

  <section title="Updates to YANG 1.1 Module Update Rules" anchor="update_rules">
      <t>
          RFC 7950 section 11, must be updated to allow for non-backwards changes provided they follow the
          semantic versioning guidelines and increase the MAJOR version number when a backwards incompatible
          change is made.  The following is proposed text for this change.</t>

      <t>
      "As experience is gained with a module, it may be desirable to revise that module.
      Changes to published modules are allowed, even if they have some potential to cause interoperability
      problems, if the module-version YANG extension is used in the revision statement to clearly indicate the nature of the change."
      </t>
  </section>

  <section title="Updates to ietf-yang-library" anchor="ietf_yang_library_updates">
      <t>The ietf-semver YANG module also specifies additional ietf-yang-library <xref target="RFC7895"/>
	    <xref target="I-D.ietf-netconf-rfc7895bis"/> leafs to be
        added at the module and submodule levels.  The first is module-version, which augments
        /yanglib:yang-library/yanglib:module-set/yanglib:module.  This specifies the current semantic version
        of the associated module and revision in a given module-set.  The related submodule-version leaf is added at
        /yanglib:yang-library/yanglib:module-set/yanglib:module/yanglib:submodule to indicate the semantic version of
        a submodule.</t>
      <t>In order to satisfy the requirement that deprecated and obsolete node presence and operation are easily and clearly
        known to clients, ietf-semver also augments the ietf-yang-library with two additional boolean leafs at
        /yanglib:yang-library/yanglib:module-set/yanglib:module.  A client can make one request of the ietf-yang-library and
        know whether or a not a module that has deprecated or obsolete has those nodes implemented by the server, as opposed to
        making multiple requests for each node in question.
        <list style="hanging">
          <t hangText="deprecated-nodes-present :">A boolean that indicates whether or not this server implements deprecated nodes.
           The value of this leaf SHOULD be true; and if so, the server MUST implement nodes
           within this module as they are documented.  If specific deprecated nodes are not
           implemented as document, then they MUST be listed as deviations.  This leaf defaults to true.</t>
          <t hangText="obsolete-nodes-present :">A boolean that indicates whether or not this server implements obsolete nodes.
           The value of this leaf SHOULD be false; and if so, the server MUST NOT implement
           nodes within this module. If this leaf is true, then all nodes in this module MUST
           be implemented as documented in the module.  Any variation of this MUST be listed as
           deviations.  This leaf defaults to false.</t>
         </list>
       </t>
       <t>
         If a module does not have any deprecated or obsolete nodes, the server SHOULD set the corresponding leaf above
         to true.  This is helpful to clients, such that if the MAJOR version number has not changed, and these booleans are
         true, then a client does not have to check the status of any node for the module.
       </t>
       <t>Module compatibility can be affected if values other than the default are used for the leafs described here.
         For example, if a server does
         not implemennt deprecated nodes, then a given module revision may be incompatible with a previous revision where
         the nodes were not deprecated.  When calculating backwards compatibility, the default values of these
         leafs MUST be considered.  From a client's point of view, if two module revisions have the same MAJOR version
         but the run-time value of deprecated-nodes-present (as read from the ietf-yang-library) is false, then
         compatibility MUST NOT be assumed based on the module-version alone.</t>
  </section>

  <section title="Deprecated and Obsolete Reasons" anchor="deprecated_and_obsolete_reasons">
    <t>The ietf-semver module specifies an extension, status-description, that is designed to be used as
      a substatement of the status statement when the status is deprecated or obsolete.  This argument to
      this extension is freeform text that explains why the node was deprecated or made obsolete.  It may also
      point to other schema elements that take the place of the deprecated or obsolete node.  This text
      is designed for human consumption to aid in the migration away from nodes that will one day no longer work.
      An example is shown below.</t>

      <figure>
        <artwork>
leaf imperial-temperature {
  type int64;
  units "degrees Fahrenheit";
  status deprecated {
    semver:status-description
      "Imperial measurements are being phased out in favor
       of their metric equivalents.  Use metric-temperature
       instead.";
  }
  description
    "Temperature in degrees Fahrenheit.";
}
        </artwork>
      </figure>
    </section>
  </section>

<section anchor="yang_module" title="Semantic Version Extension YANG Module">
  <t>
    The extension and related ietf-yang-library changes described in this module are
    defined in the YANG module below.
  </t>
  <t>
    <figure>
      <artwork><![CDATA[
<CODE BEGINS> file "ietf-semver@2018-04-05.yang"
  module ietf-semver {
    yang-version 1.1;
    namespace "urn:ietf:params:xml:ns:yang:ietf-semver";
    prefix semver;

    import ietf-yang-library {
      prefix yanglib;
    }

    organization
      "IETF NETMOD (Network Modeling) Working Group";
    contact
      "WG Web:   <https://datatracker.ietf.org/wg/netmod/>
       WG List:  <mailto:netmod@ietf.org>

       Author:   Benoit Claise
                 <mailto:bclaise@cisco.com>

       Author:   Joe Clarke
                 <mailto:jclarke@cisco.com>

       Author:   Kevin D'Souza
                 <mailto:kd6913@att.com>

       Author:   Balazs Lengyel
                 <mailto:balazs.lengyel@ericsson.com>";
    description
      "This module contains a definition for a YANG 1.1 extension to
       express the semantic version of YANG modules.";

    revision 2018-04-05 {
      description
        "* Properly import ietf-yang-library.
         * Fix the name of module-semver => module-version.
         * Fix regular expression syntax.
         * Augment yang-library with booleans as to whether or not
           deprecated and obsolete nodes are present.
         * Add an extension to enable import by semantic version.
         * Add an extension status-description to track deprecated
           and obsolete reasons.
         * Fix yang-library augments to use 7895bis.";
      reference
        "draft-clacla-netmod-yang-model-update:
         New YANG Module Update Procedure";
      semver:module-version "0.2.1";
    }
    revision 2017-12-15 {
      description
        "Initial revision.";
      reference
        "draft-clacla-netmod-yang-model-update:
         New YANG Module Update Procedure";
      semver:module-version "0.1.1";
    }

    extension module-version {
      argument semver;
      description
        "The version number for the module revision it is used in.
         This is expressed as a semantic version string in the form:
          x.y.z
         where:
          * x corresponds to the major version,
          * y corresponds to a minor version,
          * z corresponds to a patch version.

         A major version number of 0 indicates that this model is still
         in development, and is potentially subject to change.

         Following a release of major version 1, all modules will
         increment major revision number where backwards incompatible
         changes to the model are made.

         The minor version is changed when features are added to the
         model that do not impact current clients use of the model.
         When major version is stepped, the minor version is reset to 0.

         The patch-level version is incremented when non-feature changes
         (such as bugfixes or clarifications to human-readable
         descriptions that do not impact model functionality) are made
         that maintain backwards compatibility.
         When major or minor version is stepped, the patch-level is
         reset to 0.

         By comparing the module-version between two revisions of a
         given module, one can know if different revisions are backwards
         compatible or not, as well as
         whether or not new features have been added to a newer revision.

         If a module contains this extension it indicates that for this
         module the updated status and update rules as this described in
         RFC XXXX are used.

         The statement MUST only be a substatement of the revision statement.
         Zero or one module-version statement is allowed per parent
         statement. NO substatements are allowed.
        ";
      reference "http://semver.org/ : Semantic Versioning 2.0.0";
    }

    extension import-versions {
      argument version-clause;
      description
        "This extension specifies an acceptable set of semantic versions of a given module
         that may be imported.  The version-clause argument is specified in the following
         format

         [\\[(]X[.Y[.Z]][-[X[.Y[.X]]][\\])]][,...]

         Where the first character MAY be a '[' or '(' to indicate at least inclusive and at least
          exclusive (respectively).  If this is omitted, a full semantic version must be specified
          and the import will only support this one version.

         The following version, if specified with a '[' or '(' indicates the lower bound.  This can
          be a full semantic version or a MAJOR only or MAJOR.MINOR only.

         The '-', if specified, is a literal hyphen indicating a range will be specified.  If the second portion
          of the import-versions clause is omitted, then there is no upper bound on what will be considered
          an acceptable imported version.

         After the '-' the upper bound semantic version (or part thereof) follows.
         After the upper bound version, one of ']' or ')' MUST follow to indicate whether this limit is inclusive
          or exclusive of the upper bound respectively.

         Finally, a literal comma (',') MAY be specified with additional ranges.  Each range is taken as a logical
          OR.

         The statement MUST only be a substatement of the import statement.  Zero or one
         import-versions statement is allowed per import statement.  NO substatements are allowed.";
      reference "I-D.clacla-netmod-yang-model-update : Import By Semantic Version";
    }

    extension status-description {
      argument description;
      description
        "Freeform text that describes why a given node has been deprecated or made obsolete.
         This may point to other schema elements that can be used in lieu of the given node.

         This statement MUST only be used as a substatement of the status statement, and MUST
         only be used when the status is deprecated or obsolete.  Zero or more status-description
         statements are allowed per parent statement.  NO substatements are allowed.";
      reference "I-D.clacla-netmod-yang-model-update : Deprecated and Obsolete Reasons";
    }

    augment "/yanglib:yang-library/yanglib:module-set/yanglib:module" {
      description
        "Augmentations for the ietf-yang-library module to support semantic versioning.";
      leaf module-version {
        type string {
          pattern '[0-9]+\.[0-9]+\.[0-9]+';
        }
        description
          "The semantic version for this module in MAJOR.MINOR.PATCH format.  This version
           must match the semver:module-version value in specific revision of the module
           loaded in this module-set.";
      }
      leaf deprecated-nodes-present {
        type boolean;
        default "true";
        description
          "A boolean that indicates whether or not this server implements deprecated nodes.
           The value of this leaf SHOULD be true; and if so, the server MUST implement nodes
           within this module as they are documented.  If specific deprecated nodes are not
           implemented as document, then they MUST be listed as deviations.  If a module does
           not currently contain any deprecated nodes, then this leaf SHOULD be set to true.";
      }
      leaf obsolete-nodes-present {
        type boolean;
        default "false";
        description
          "A boolean that indicates whether or not this server implements obsolete nodes.
           The value of this leaf SHOULD be false; and if so, the server MUST NOT implement
           nodes within this module. If this leaf is true, then all nodes in this module MUST
           be implemented as documented in the module.  Any variation of this MUST be listed as
           deviations.  If a module does not currently contain any obsolete nodes, then this
           leaf SHOULD be set to true.";
      }
    }
    augment "/yanglib:yang-library/yanglib:module-set/yanglib:module/yanglib:submodule" {
      description
        "Augmentations for the ietf-yang-library module/submodule to support semantic versioning.";
      leaf submodule-version {
        type string {
          pattern '[0-9]+\.[0-9]+\.[0-9]+';
        }
        description
          "The semantic version for this submodule in MAJOR.MINOR.PATCH format.  This version
           must match the semver:module-version value in specific revision of the submodule
           loaded in this module-set.";
      }
    }
  }
<CODE ENDS>
]]></artwork>
</figure>
</t>
</section>

<section anchor="contributor" title="Contributors">
  <t>
   <list style="symbols">
     <t>Anees Shaikh, Google
     </t>
     <t>Rob Shakir, Google
     </t>
   </list>
  </t>
</section>

<section anchor="security" title="Security Considerations">
  <t>
 The document does not define any new protocol or data model.
 There are no security impacts.
 </t>
</section>
<section anchor="iana" title="IANA Considerations">
  <section anchor="yang-module-registrations" title="YANG Module Registrations">
  <t>The following YANG module is requested to be registred in the "IANA
  Module Names" registry:</t>

  <t>The ietf-semver module:</t>

  <t><list style="symbols">
    <t>Name: ietf-semver</t>
    <t>XML Namespace: urn:ietf:params:xml:ns:yang:ietf-semver</t>
    <t>Prefix: semver</t>
    <t>Reference: [RFCXXXX]</t>
  </list></t>
</section>
</section>
</middle>
<?rfc needLines="20"?>
<back>
<references title="Normative References">
   <?rfc include='reference.RFC.7950'?>
   <?rfc include='reference.RFC.7895'?>
</references>
<references title="Informative References">
   <?rfc include='reference.RFC.8049'?>
   <?rfc include='reference.RFC.8199'?>
   <?rfc include='reference.RFC.8299'?>
   <?rfc include='reference.I-D.openconfig-netmod-model-catalog'?>
   <?rfc include='reference.I-D.claise-semver'?>
   <?rfc include='reference.I-D.clacla-netmod-model-catalog'?>
   <?rfc include='reference.I-D.ietf-netconf-rfc7895bis'?>
   <reference anchor="openconfigsemver" target="http://www.openconfig.net/docs/semver/">
     <front>
      <title>Semantic Versioning for Openconfig Models</title>
      <author/>
      <date/>
    </front>
   </reference>
      <reference anchor="semver" target="https://www.semver.org">
      <front>
       <title>Semantic Versioning 2.0.0</title>
       <author/>
       <date/>
    </front>
   </reference>
   <reference anchor="yangcatalog" target="https://yangcatalog.org">
     <front>
       <title>YANG Catalog</title>
       <author/>
       <date/>
     </front>
   </reference>
</references>
<?rfc needLines="100"?>

<section anchor="appendix" title="Appendix">
  <section anchor="open_issues" title="Open Issues">
    <t>
        There are a number of open issues to be disccused.  These include the following:
    </t>

    <t>
      <list style="symbols">
        <t>Do we need a new version of YANG?
          <vspace/>
          While eventually this will fold into a new version, the belief is this solution can
          work with extensions alone with an update to the <xref target="RFC7950"/> text concerning
          module updates.</t>
        <t>Should IETF/IANA officially generate derived semantic versions for their own modules?
        As they are the owner of the modules it should be their responsibility, but how to document it?
		Note that next round of funding for the yangcatalog.org could help develop the perfect
		derived-semantic-version toolset
        </t>
        <t>We could consider a new naming convention for module files. Today, module files
          are named using a  module@revision.yang notation.  We could consider module%semver.yang
          or module#version.yang variants.
          Re-using the '@' for version is not ideal, so another separator character should be used.
          In this manner, both version and revision could be used.
          </t>
        <t>Taking another page from Openconfig, the notion of a module bundle could be considered. That is, there
          may need to be a way to enumerate modules that are part of a bundle and are known to interoperate.  This
          may not be as critical if a rich import-by-version is defined.
          <vspace/>
          While the issue is interesting, it will be not be handled in this document.</t>
        <t>Similarly, the concept of a feature bundle should be considered.  Typically, operators combine and test YANG modules
          to build value-add services.  These bundles form releases for specific features or services, and it is critical
          to ensure as the modules evolve, the bundles can coherently evolve with them.
          <vspace/>
          While the issue is interesting, it will be not be handled in this document.
          </t>
        <t>When we'll start using this new procedure for a new YANG module revision,
        will we have to update all the dependent YANG modules to start using this
        new procedure, along with the new import statement? Is this a moot point,
        as a new YANG module name would suffer from the same symptoms?
        <vspace/>
        We see no need for updating other dependent modules. It is a good idea to
        update them, as they will benefit from using SEMVER, however there is no specific
        need to update them.</t>
      </list>
    </t>
  </section>
</section>
</back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->
